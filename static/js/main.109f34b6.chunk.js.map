{"version":3,"sources":["core/squares.ts","core/utils.ts","Field.tsx","core/speedLevels.ts","Settings.tsx","Score.tsx","core/score.ts","GameOver.tsx","core/selectors.ts","core/moveSnake.ts","core/snake.ts","core/newGame.ts","core/changeDirection.ts","App.tsx","index.tsx"],"names":["snakeHead","type","bodyPart","id","uuidv4","snakeTrunk","index","snakeTail","food","emptySquare","WIDTH","HEIGHT","oppositeDirections","sort","join","height","flattenedCoordinatesField","Array","fill","map","column","xIndex","value","yIndex","x","y","flat","generateFoodCoordinates","seed","fieldWithSnake","freeCoordinates","filter","max","min","rng","seedrandom","Math","floor","createRandomNumberGenerator","length","random","createEmptyField","width","EmptySquare","styled","div","SnakeSquare","SnakeHead","SnakeTrunk","SnakeTail","FoodSquare","FieldSquare","square","SnakeBox","Field","renderedField","gameState","field","row","rowIndex","columnIndex","speedMap","delay","description","getDefaultSpeed","findIndex","Controls","SpeedControl","Settings","onSpeedChange","useState","speed","setSpeed","useEffect","onClick","previous","step","onChange","event","newSpeed","parseInt","target","Score","current","score","setScore","startingScore","options","countDelay","writable","subscribe","update","newScore","setTimeout","startScoring","scoreStore","Overlay","GameOver","onNewGameClick","finalScore","selectField","selectDirection","direction","selectSnakeSize","snakeSize","getNewHeadCoordinates","headCoordinates","fn","coordinates","forEach","rowArray","findCoordinatesForSquare","newHeadColumn","newHeadRow","defaultDelay","noop","startSnakeGame","logger","foodCoordinates","foodConsumed","gameOver","newGame","commandQueue","lastDelay","paused","startTimer","setInterval","newDirection","direction1","direction2","oldDirection","indexOf","changeDirection","actuallyChangeDirection","shift","newState","newHeadCoordinates","foodConsumedOnThisMove","newField","moveSnake","clearInterval","previousIntervalId","changeDelayBetweenMoves","newDelay","push","togglePause","destroy","Main","main","Game","StyledScore","span","Title","h1","App","snakeGame","setSnakeGame","undefined","setGameState","newGameState","handleKeypress","key","toLowerCase","window","addEventListener","removeEventListener","handleSpeedChange","useCallback","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.109f34b6.chunk.js","sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport type { Square } from './types';\n\nexport function snakeHead(): Square {\n  return { type: 'snake', bodyPart: 'head', id: uuidv4() };\n}\n\nexport function snakeTrunk({ index }: { index: number }): Square {\n  return { type: 'snake', bodyPart: 'trunk', index, id: uuidv4() };\n}\n\nexport function snakeTail(): Square {\n  return { type: 'snake', bodyPart: 'tail', id: uuidv4() };\n}\n\nexport function food(): Square {\n  return { type: 'food', id: uuidv4() };\n}\n\nexport function emptySquare(): Square {\n  return { type: 'empty', id: uuidv4() };\n}\n","import seedrandom from 'seedrandom';\nimport { emptySquare } from './squares';\nimport type { Direction, Field, Square } from './types';\n\nexport const WIDTH = 32;\nexport const HEIGHT = 17;\nexport const STARTING_ROW = 8;\n\nexport function createRandomNumberGenerator(\n  seed: number | string,\n  { max, min = 0 }: { max: number; min?: number },\n): () => number {\n  const rng = seedrandom(seed);\n  return () => min + Math.floor(rng() * max);\n}\n\nexport function createFlattenedCoordinatesField(\n  width: number,\n  height: number,\n): Array<{ x: number; y: number }> {\n  const emptyField = new Array(width).fill(null).map(() => new Array(height).fill(null));\n  const coordinatesField = emptyField.map((column, xIndex) => {\n    return column.map((value, yIndex) => {\n      return { x: xIndex, y: yIndex };\n    });\n  });\n  return coordinatesField.flat();\n}\n\nexport function findCoordinatesForSquare(\n  field: Field,\n  fn: (square: Square) => boolean,\n): { row: number; column: number } {\n  let coordinates;\n  field.forEach((rowArray, row) => {\n    rowArray.forEach((square, column) => (fn(square) ? (coordinates = { row, column }) : null));\n  });\n\n  return coordinates;\n}\n\nconst oppositeDirections = [['left', 'right'].sort().join(','), ['up', 'down'].sort().join(',')];\n\nexport function areOpposite(direction1: Direction, direction2: Direction): boolean {\n  return oppositeDirections.indexOf([direction1, direction2].sort().join(',')) >= 0;\n}\n\nconst flattenedCoordinatesField = createFlattenedCoordinatesField(HEIGHT, WIDTH);\n\n/**\n * Pick food location at random, avoiding fields occupied by the snake.\n */\nexport function generateFoodCoordinates(\n  seed: string | number,\n  fieldWithSnake: Field,\n): { x: number; y: number } {\n  // Selecting from an array of free coordinates ensures that each field has the same chance of containing food.\n  const freeCoordinates = flattenedCoordinatesField.filter(({ x, y }) => {\n    return fieldWithSnake[x][y]?.type !== 'snake';\n  });\n\n  const random = createRandomNumberGenerator(seed, { max: freeCoordinates.length });\n  return freeCoordinates[random()];\n}\n\nexport function createEmptyField(width: number, height: number): Field {\n  return new Array(height)\n    .fill(null)\n    .map(() => new Array(width).fill(null).map(() => emptySquare()));\n}\n","import React, { FunctionComponent } from 'react';\nimport styled from 'styled-components';\nimport { GameState, Square } from './core/types';\nimport { HEIGHT, WIDTH } from './core/utils';\n\nconst EmptySquare = styled.div`\n  width: 3.4vh;\n  height: 3.4vh;\n`;\n\nconst SnakeSquare = styled(EmptySquare)`\n  background-color: black;\n`;\n\nconst SnakeHead = styled(SnakeSquare)`\n  width: 3.4vh;\n  height: 3.4vh;\n`;\n\nconst SnakeTrunk = styled(SnakeSquare)`\n  width: 3.1vh;\n  height: 3.1vh;\n`;\n\nconst SnakeTail = styled(SnakeSquare)`\n  width: 2.5vh;\n  height: 2.5vh;\n`;\n\nconst FoodSquare = styled(EmptySquare)`\n  background-color: #ff3e00;\n  border-radius: 50%;\n  width: 3vh;\n  height: 3vh;\n`;\n\nconst FieldSquare: FunctionComponent<{ square: Square }> = ({ square }) => {\n  if (square?.type === 'snake') {\n    switch (square.bodyPart) {\n      case 'head':\n        return <SnakeHead />;\n      case 'trunk':\n        return <SnakeTrunk />;\n      case 'tail':\n        return <SnakeTail />;\n    }\n  }\n\n  if (square?.type === 'food') {\n    return <FoodSquare />;\n  }\n\n  return <EmptySquare />;\n};\n\nconst SnakeBox = styled.div`\n  display: grid;\n  grid-template-columns: repeat(${WIDTH}, 3.6vh);\n  grid-template-rows: repeat(${HEIGHT}, 3.6vh);\n  place-items: center center;\n  gap: 0.15vh 0.15vh;\n  padding: 0.15vh;\n  border: 3px solid black;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell,\n    'Helvetica Neue', sans-serif;\n`;\n\nconst Field: FunctionComponent<{ gameState: GameState }> = ({ gameState }) => {\n  const renderedField = gameState.field.map((row, rowIndex) => {\n    return row.map((square, columnIndex) => (\n      <FieldSquare key={`${rowIndex}${columnIndex}`} square={square} />\n    ));\n  });\n\n  return <SnakeBox>{renderedField}</SnakeBox>;\n};\n\nexport default Field;\n","// Order is important\nexport const speedMap = [\n  { delay: 300000, description: '\"Need to make some coffee\" speed' }, // cca. 5 minutes between moves\n  { delay: 700, description: 'Dead snail on a slope' },\n  { delay: 540, description: 'Snail' },\n  { delay: 400, description: 'Sloth' },\n  { delay: 320, description: 'Snail running from a bird' },\n  { delay: 230, description: 'Turtle' },\n  { delay: 160, description: 'Turtle on a skateboard' },\n  { delay: 80, description: 'Regular speed' },\n  { delay: 50, description: 'Fast' },\n  { delay: 30, description: 'Cheetah' },\n  { delay: 20, description: 'Cheetah driving a Porsche' },\n  { delay: 10, description: 'M-497 Black Beetle' },\n  { delay: 4, description: 'Warp 11' }, // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval#delay_restrictions\n];\n\nexport function getDefaultSpeed(): number {\n  return speedMap.findIndex((value) => value.delay === 80);\n}\n","import React, { ChangeEvent, FunctionComponent, useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport { speedMap, getDefaultSpeed } from './core/speedLevels';\n\nconst Controls = styled.div`\n  margin-top: 10px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: flex-start;\n  height: 50px;\n  min-width: 500px;\n\n  /* BEGIN Apply styles that allow us to customize range input */\n  input[type='range'] {\n    -webkit-appearance: none;\n    width: 15vw; /* Specific width is required for Firefox. */\n    background: transparent; /* Otherwise white in Chrome */\n  }\n\n  input[type='range']::-webkit-slider-thumb {\n    -webkit-appearance: none;\n  }\n\n  input[type='range']:focus {\n    outline: none; /* Removes the blue border. You should probably do some kind of focus styling for accessibility reasons though. */\n  }\n\n  input[type='range']::-ms-track {\n    width: 100%;\n    cursor: pointer;\n\n    /* Hides the slider so custom styles can be added */\n    background: transparent;\n    border-color: transparent;\n    color: transparent;\n  }\n  /* END Apply styles that allow us to customize range input */\n\n  /* Special styling for WebKit/Blink */\n  input[type='range']::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    border: 2px solid #000000;\n    height: 16px;\n    width: 16px;\n    border-radius: 3px;\n    background: #ffffff;\n    cursor: pointer;\n  }\n\n  /* All the same stuff for Firefox */\n  input[type='range']::-moz-range-thumb {\n    border: 2px solid #000000;\n    height: 16px;\n    width: 16px;\n    border-radius: 3px;\n    background: #ffffff;\n    cursor: pointer;\n  }\n\n  input[type='range']:focus {\n    outline: none; /* Removes the blue border. You should probably do some kind of focus styling for accessibility reasons though. */\n  }\n\n  input[type='range']::-ms-track {\n    width: 100%;\n    cursor: pointer;\n\n    /* Hides the slider so custom styles can be added */\n    background: transparent;\n    border-color: transparent;\n    color: transparent;\n  }\n\n  button {\n    border: 2px solid black;\n    background-color: white;\n    height: 24px;\n    font-weight: bold;\n    font-size: 14px;\n  }\n\n  button:hover {\n    background-color: black;\n    color: white;\n  }\n`;\n\nconst SpeedControl = styled.div`\n  display: flex;\n  margin-top: 4px;\n`;\n\nconst Settings: FunctionComponent<{ onSpeedChange: (speed: number) => void }> = ({\n  onSpeedChange,\n}) => {\n  const [speed, setSpeed] = useState(getDefaultSpeed());\n\n  useEffect(() => {\n    onSpeedChange(speedMap[speed].delay);\n  }, [onSpeedChange, speed]);\n\n  function incrementSpeed() {\n    if (speed < speedMap.length - 1) {\n      setSpeed((previous) => previous + 1);\n    }\n  }\n\n  function decrementSpeed() {\n    if (speed > 0) {\n      setSpeed((previous) => previous - 1);\n    }\n  }\n\n  function handleSpeedChange(event: ChangeEvent<HTMLInputElement>) {\n    const newSpeed = parseInt(event.target.value, 10);\n    setSpeed(newSpeed);\n    onSpeedChange(speedMap[newSpeed].delay);\n  }\n\n  return (\n    <Controls>\n      <span>{speedMap[speed].description}</span>\n      <SpeedControl>\n        <button onClick={decrementSpeed}>&#xFF0D;</button>\n        <input\n          type=\"range\"\n          value={speed}\n          min=\"0\"\n          max={speedMap.length - 1}\n          step=\"1\"\n          onChange={handleSpeedChange}\n        />\n        <button onClick={incrementSpeed}>&#xFF0B;</button>\n      </SpeedControl>\n    </Controls>\n  );\n};\n\nexport default Settings;\n","import React, { FunctionComponent, useEffect, useState } from 'react';\nimport startScoring from './core/score';\n\nconst Score: FunctionComponent<{ current: number }> = ({ current }) => {\n  const [score, setScore] = useState(0);\n  const [scoreStore] = useState(startScoring());\n\n  useEffect(() => {\n    const unsubscribe = scoreStore.subscribe((newScore) => {\n      setScore(newScore);\n    });\n\n    return unsubscribe;\n  }, [scoreStore]);\n\n  scoreStore.newScore(current);\n\n  return (\n    <>\n      Score: <span>{score}</span>\n    </>\n  );\n};\n\nexport default Score;\n","import { writable } from 'svelte/store';\n\ninterface ScoreStore {\n  subscribe(subscriber): () => void;\n  newScore(newScore: number): void;\n}\n\nexport default function startScoring(startingScore = 0, options = { countDelay: 20 }): ScoreStore {\n  const { subscribe, update } = writable(startingScore);\n  let current = startingScore;\n\n  return {\n    subscribe,\n    newScore(newScore) {\n      if (newScore < current) {\n        const difference = current - newScore;\n        const step = 1500 / difference;\n        if (step < 4) {\n          update(() => newScore);\n        } else {\n          for (let index = current; index > newScore; index--) {\n            setTimeout(() => update((previous) => previous - 1), index * step);\n          }\n        }\n      } else {\n        for (let index = 1; index <= newScore - current; index++) {\n          setTimeout(() => update((previous) => previous + 1), index * options.countDelay);\n        }\n      }\n      current = newScore;\n    },\n  };\n}\n","import React, { FunctionComponent } from 'react';\nimport styled from 'styled-components';\n\nconst Overlay = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  opacity: 0.9;\n  background-color: black;\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n  z-index: 1000;\n\n  h1 {\n    color: white;\n  }\n\n  p {\n    color: #ff3e00;\n    text-transform: uppercase;\n    font-size: 6vh;\n  }\n\n  button {\n    position: relative;\n    border-style: none;\n    border-radius: 0.4rem;\n    width: 180px;\n    height: 3.5rem;\n    background-color: #ff3e00;\n    color: white;\n    font-size: 1rem;\n    font-weight: bold;\n    padding: 8px 22px;\n    text-transform: uppercase;\n  }\n\n  button:hover {\n    background-color: #ff4000c5;\n    cursor: pointer;\n  }\n\n  button:active {\n    background-color: #ff3e00;\n    cursor: pointer;\n  }\n`;\n\nconst GameOver: FunctionComponent<{ onNewGameClick: () => void; finalScore: number }> = ({\n  onNewGameClick,\n  finalScore,\n}) => {\n  return (\n    <Overlay>\n      <h1>Game over</h1>\n      <p>Final score: {finalScore}</p>\n      <button onClick={onNewGameClick}> New game </button>\n    </Overlay>\n  );\n};\n\nexport default GameOver;\n","import type { Direction, Field, GameState } from './types';\n\nexport function selectField(gameState: GameState): Field {\n  return gameState.field;\n}\n\nexport function selectDirection(gameState: GameState): Direction {\n  return gameState.direction;\n}\n\nexport function selectSnakeSize(gameState: GameState): number {\n  return gameState.snakeSize;\n}\n","import { WIDTH, HEIGHT, findCoordinatesForSquare, generateFoodCoordinates } from './utils';\nimport { selectDirection, selectField, selectSnakeSize } from './selectors';\nimport { snakeHead, snakeTail, snakeTrunk, food, emptySquare } from './squares';\nimport type { GameState } from './types';\n\nexport function moveSnake(\n  gameState: GameState,\n  seed = Math.floor(Math.random() * 10000000),\n): GameState {\n  const field = selectField(gameState);\n  const snakeSize = selectSnakeSize(gameState);\n  const newHeadCoordinates = getNewHeadCoordinates(field, selectDirection(gameState));\n\n  if (\n    field[newHeadCoordinates.row][newHeadCoordinates.column]?.type === 'snake' &&\n    field[newHeadCoordinates.row][newHeadCoordinates.column].bodyPart != 'tail'\n  ) {\n    return { ...gameState, gameOver: true };\n  }\n\n  let foodConsumedOnThisMove = false;\n  const newField = field.map((row, rowIndex) => {\n    return row.map((square, columnIndex) => {\n      // Tail moves away unless food was consumed on previous move\n      if (square?.type === 'snake' && square.bodyPart === 'tail') {\n        if (newHeadCoordinates.row === rowIndex && newHeadCoordinates.column === columnIndex) {\n          return { ...snakeHead(), id: square.id };\n        }\n        return gameState.foodConsumed ? square : { ...emptySquare(), id: square.id };\n      }\n      // Head becomes trunk\n      if (square?.type === 'snake' && square.bodyPart === 'head') {\n        return { ...snakeTrunk({ index: 0 }), id: square.id };\n      }\n      if (square?.type === 'snake' && square.bodyPart === 'trunk') {\n        // Last trunk element is now a tail unless food was consumed on previous move\n        if (square.index === snakeSize - 3 && !gameState.foodConsumed) {\n          return { ...snakeTail(), id: square.id };\n        }\n\n        return { ...snakeTrunk({ index: square.index + 1 }), id: square.id };\n      }\n      if (\n        (square.type === 'empty' || square.type === 'food') &&\n        columnIndex === newHeadCoordinates.column &&\n        rowIndex === newHeadCoordinates.row\n      ) {\n        if (square) {\n          foodConsumedOnThisMove = square.type === 'food';\n        }\n        return { ...snakeHead(), id: square.id };\n      }\n\n      return square;\n    });\n  });\n\n  if (gameState.foodConsumed) {\n    const foodCoordinates = generateFoodCoordinates(seed, newField);\n    newField[foodCoordinates.x][foodCoordinates.y] = {\n      ...food(),\n      id: newField[foodCoordinates.x][foodCoordinates.y].id,\n    };\n  }\n\n  return {\n    ...gameState,\n    foodConsumed: foodConsumedOnThisMove,\n    field: newField,\n    snakeSize: gameState.foodConsumed ? gameState.snakeSize + 1 : gameState.snakeSize,\n    score: foodConsumedOnThisMove ? gameState.score + 5 : gameState.score,\n  };\n}\n\nfunction getNewHeadCoordinates(field, direction) {\n  const headCoordinates = findCoordinatesForSquare(\n    field,\n    (square) => square?.type === 'snake' && square.bodyPart === 'head',\n  );\n\n  let newHeadColumn = headCoordinates.column;\n  if (direction === 'left') {\n    newHeadColumn = headCoordinates.column - 1 < 0 ? WIDTH - 1 : headCoordinates.column - 1;\n  } else if (direction === 'right') {\n    newHeadColumn = headCoordinates.column + 1 === WIDTH ? 0 : headCoordinates.column + 1;\n  }\n\n  let newHeadRow = headCoordinates.row;\n  if (direction === 'up') {\n    newHeadRow = headCoordinates.row - 1 < 0 ? HEIGHT - 1 : headCoordinates.row - 1;\n  } else if (direction === 'down') {\n    newHeadRow = headCoordinates.row + 1 === HEIGHT ? 0 : headCoordinates.row + 1;\n  }\n\n  return { row: newHeadRow, column: newHeadColumn };\n}\n","import { writable } from 'svelte/store';\nimport { changeDirection } from './changeDirection';\nimport { moveSnake } from './moveSnake';\nimport { newGame } from './newGame';\nimport { getDefaultSpeed, speedMap } from './speedLevels';\nimport type { Direction } from './types';\n\nconst defaultDelay = speedMap[getDefaultSpeed()].delay;\n\ninterface snakeGameOptions {\n  delay?: number;\n  logger?: (message) => void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {};\n\nexport interface SnakeGame {\n  subscribe(subscriber): () => void;\n  changeDirection(direction: Direction): void;\n  changeDelayBetweenMoves(newDelay: number): void;\n  togglePause(): void;\n  destroy(): void;\n}\n\nexport default function startSnakeGame({\n  delay = defaultDelay,\n  logger = noop,\n}: snakeGameOptions): SnakeGame {\n  const { subscribe, update } = writable(newGame());\n  const commandQueue = [];\n  let lastDelay = delay;\n  let paused = false;\n\n  function startTimer(delay) {\n    return setInterval(() => {\n      logger(`Calling setInterval handler (delay: ${delay})`);\n      actuallyChangeDirection(update, commandQueue.shift());\n      update((previous) => {\n        const newState = moveSnake(previous);\n        if (newState.gameOver) {\n          clearInterval(previousIntervalId);\n        }\n\n        return newState;\n      });\n    }, delay);\n  }\n\n  let previousIntervalId = startTimer(delay);\n\n  function changeDelayBetweenMoves(newDelay) {\n    lastDelay = newDelay;\n    clearInterval(previousIntervalId);\n    previousIntervalId = startTimer(newDelay);\n  }\n\n  return {\n    subscribe,\n    changeDirection(direction) {\n      if (!paused) {\n        commandQueue.push(direction);\n      }\n    },\n    changeDelayBetweenMoves,\n    togglePause() {\n      if (paused) {\n        changeDelayBetweenMoves(lastDelay);\n        paused = false;\n      } else {\n        paused = true;\n        clearInterval(previousIntervalId);\n      }\n    },\n    destroy() {\n      clearInterval(previousIntervalId);\n    },\n  };\n}\n\nfunction actuallyChangeDirection(update, newDirection) {\n  if (newDirection) {\n    update((previous) => changeDirection(previous, newDirection));\n  }\n}\n","import { WIDTH, HEIGHT, STARTING_ROW, createEmptyField, generateFoodCoordinates } from './utils';\nimport { snakeHead, snakeTail, snakeTrunk, food } from './squares';\nimport type { GameState } from './types';\n\nexport function newGame(seed = Math.floor(Math.random() * 10000000)): GameState {\n  const field = createEmptyField(WIDTH, HEIGHT);\n  field[STARTING_ROW][13] = snakeTail();\n  field[STARTING_ROW][14] = snakeTrunk({ index: 3 });\n  field[STARTING_ROW][15] = snakeTrunk({ index: 2 });\n  field[STARTING_ROW][16] = snakeTrunk({ index: 1 });\n  field[STARTING_ROW][17] = snakeTrunk({ index: 0 });\n  field[STARTING_ROW][18] = snakeHead();\n\n  const foodCoordinates = generateFoodCoordinates(seed, field);\n  field[foodCoordinates.x][foodCoordinates.y] = food();\n\n  return {\n    field,\n    direction: 'right',\n    snakeSize: 6,\n    foodConsumed: false,\n    gameOver: false,\n    score: 0,\n  };\n}\n","import { areOpposite } from './utils';\nimport { selectDirection } from './selectors';\nimport type { Direction, GameState } from './types';\n\nexport function changeDirection(gameState: GameState, newDirection: Direction): GameState {\n  const oldDirection = selectDirection(gameState);\n\n  return {\n    ...gameState,\n    direction: areOpposite(oldDirection, newDirection) ? oldDirection : newDirection,\n  };\n}\n","import React, { FunctionComponent, KeyboardEvent, useCallback, useEffect, useState } from 'react';\nimport styled from 'styled-components';\nimport Field from './Field';\nimport Settings from './Settings';\nimport Score from './Score';\nimport GameOver from './GameOver';\nimport startSnakeGame from './core/snake';\nimport { GameState } from './core/types';\n\nconst Main = styled.main`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  text-align: center;\n`;\n\nconst Game = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n`;\n\nconst StyledScore = styled.span`\n  font-size: 2rem;\n`;\n\nconst Title = styled.h1`\n  color: #ff3e00;\n  text-transform: uppercase;\n  font-size: 8vh;\n  font-weight: 100;\n`;\n\nconst App: FunctionComponent = () => {\n  const [snakeGame, setSnakeGame] = useState(() => startSnakeGame({}));\n  const [gameState, setGameState] = useState<GameState | undefined>(undefined);\n\n  useEffect(() => {\n    snakeGame.subscribe((newGameState) => setGameState(newGameState));\n    return snakeGame.destroy;\n  }, [snakeGame]);\n\n  useEffect(() => {\n    function handleKeypress(event: KeyboardEvent) {\n      const key = event.key.toLowerCase();\n      if (key === 'w') {\n        snakeGame.changeDirection('up');\n      } else if (key === 's') {\n        snakeGame.changeDirection('down');\n      } else if (key === 'd') {\n        snakeGame.changeDirection('right');\n      } else if (key === 'a') {\n        snakeGame.changeDirection('left');\n      } else if (key === 'p') {\n        snakeGame.togglePause();\n      }\n    }\n    window.addEventListener('keypress', (handleKeypress as unknown) as EventListener);\n\n    return () =>\n      window.removeEventListener('keypress', (handleKeypress as unknown) as EventListener);\n  }, [snakeGame]);\n\n  // Prevents unnecessary renders of Settings component.\n  const handleSpeedChange = useCallback(\n    (newDelay: number) => {\n      snakeGame.changeDelayBetweenMoves(newDelay);\n    },\n    [snakeGame],\n  );\n\n  if (!gameState) {\n    return <></>;\n  }\n\n  function restart() {\n    snakeGame.destroy();\n    setSnakeGame(startSnakeGame({}));\n  }\n\n  return (\n    <Main>\n      <Title>Snake</Title>\n      <Game>\n        <StyledScore>\n          <Score current={gameState.score} />\n        </StyledScore>\n        <Field gameState={gameState} />\n      </Game>\n      <Settings onSpeedChange={handleSpeedChange} />\n      {gameState.gameOver && <GameOver onNewGameClick={restart} finalScore={gameState.score} />}\n    </Main>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}